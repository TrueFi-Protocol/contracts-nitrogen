import { expect, use } from 'chai'
import { solidity } from 'ethereum-waffle'
import { structuredIndexedPortfolioFixture, StructuredIndexedPortfolioStatus } from 'fixtures/structuredIndexedPortfolioFixture'
import { setupFixtureLoader } from 'test/setup'

use(solidity)

describe('StructuredIndexedPortfolio exploit attempts', () => {
  const loadFixture = setupFixtureLoader()

  it('share value manipulation', async () => {
    const {
      unitranchePortfolio: portfolio,
      unitranche: tranche,
      unitrancheControllers: trancheControllers,
      parseMockToken,
      token,
      wallet: maliciousActor,
      other: victim,
      allowWithdrawalsOnStatus,
      allowDepositsOnStatus,
      approveAndDepositToTranche,
    } = await loadFixture(structuredIndexedPortfolioFixture)

    const singleWei = 1
    const maliciousActorTransferAssets = parseMockToken(1_000_000)
    const victimDepositAssets = maliciousActorTransferAssets.div(2)
    await token.mint(victim.address, victimDepositAssets)

    // Frontrunning
    await approveAndDepositToTranche(tranche, singleWei, maliciousActor)
    await token.connect(maliciousActor).transfer(portfolio.address, maliciousActorTransferAssets)

    await portfolio.start()
    await allowDepositsOnStatus([trancheControllers.depositController], StructuredIndexedPortfolioStatus.Live)
    await allowWithdrawalsOnStatus([trancheControllers.withdrawController], StructuredIndexedPortfolioStatus.Live)

    await approveAndDepositToTranche(tranche, victimDepositAssets, victim)

    // LP token's values are proportional to deposited amount, not transferred amount
    expect(await tranche.maxWithdraw(victim.address)).to.eq(victimDepositAssets)
    expect(await tranche.maxWithdraw(maliciousActor.address)).to.eq(singleWei)
  })
})
